<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visuomotor Rotation Demo (Full Screen, Touch Friendly)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #f9f9ff;
        }
        #taskCanvas {
            display: block;
            position: absolute;
            left: 0; top: 0;
            width: 100vw;
            height: 100vh;
            cursor: none;
            touch-action: none; /* Prevents browser touch scrolling */
        }
        #ui {
            position: absolute;
            left: 20px; top: 20px; z-index: 2;
            color: #212259;
            background: rgba(255,255,255,0.83);
            font-size: 20px;
            font-family: Arial,sans-serif;
            padding: 10px 18px;
            border-radius: 10px;
        }
        #plot {
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 14px;
            position: absolute;
            left: 50%; top: 12%;
            transform: translate(-50%,0);
            z-index:3;
        }
    </style>
</head>
<body>
    <div id="ui">
        <b>Visuomotor Rotation Demo (30Â° full-screen)</b> <br>
        Move the green cursor from the blue home to the red target.<br>
        Trial ends automatically when cursor reaches target distance.<br>
        You can use mouse, trackpad, or touch.<br>
        <span id="trialheader"></span>
    </div>
    <canvas id="taskCanvas"></canvas>
    <div id="plot"></div>
    <script>
        // --- Parameters ---
        const ROTATION_ANGLE = 30 * Math.PI/180; // 30 degrees in radians
        const TRIALS = 30;

        let canvas = document.getElementById('taskCanvas');
        let ctx = canvas.getContext('2d');

        // State
        let w = window.innerWidth, h = window.innerHeight;
        let startRel = { x: 0.5, y: 0.85 }, targetRel = { x: 0.5, y: 0.22 };
        let radiusScale = Math.min(w,h);
        let targetRadius = 0.018 * radiusScale;
        let cursorRadius = 0.015 * radiusScale;

        function rel2px(rel) { return {x:rel.x*w, y:rel.y*h}; }
        let startPos = rel2px(startRel);
        let targetPos = rel2px(targetRel);
        let requiredDistance = Math.sqrt((startPos.x-targetPos.x)**2 + (startPos.y-targetPos.y)**2);

        let trial = 0;
        let cursor = { x: startPos.x, y: startPos.y };
        let lastInput = { x: startPos.x, y: startPos.y };
        let trialStartFlag = true;
        let reachAngles = [];
        let errorAngles = [];

        function rotate(dx, dy, theta) {
            return {
                x: dx * Math.cos(theta) - dy * Math.sin(theta),
                y: dx * Math.sin(theta) + dy * Math.cos(theta),
            };
        }
        function getAngleDeg(vec) {
            let angleRad = Math.atan2(-(vec.y), vec.x);
            return angleRad * 180 / Math.PI;
        }
        function angleDiffDeg(a, b) {
            let d = a - b;
            while (d > 180) d -= 360;
            while (d < -180) d += 360;
            return d;
        }
        function dist(a, b) {
            return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
        }

        function drawScreen() {
            ctx.clearRect(0, 0, w, h);

            // Target
            ctx.beginPath();
            ctx.arc(targetPos.x, targetPos.y, targetRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();

            // Home position
            ctx.beginPath();
            ctx.arc(startPos.x, startPos.y, targetRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Green visual cursor
            ctx.beginPath();
            ctx.arc(cursor.x, cursor.y, cursorRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'green';
            ctx.fill();

            document.getElementById('trialheader').innerHTML =
                `Trial: <b>${trial+1}</b> / ${TRIALS}<br>` +
                (trial === 0 ? "Move green cursor from home to target. Trial ends automatically." : "");
        }

        // Handle full-screen and scaling
        function resizeCanvas() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
            radiusScale = Math.min(w,h);
            targetRadius = 0.018 * radiusScale;
            cursorRadius = 0.015 * radiusScale;
            startPos = rel2px(startRel);
            targetPos = rel2px(targetRel);
            requiredDistance = dist(startPos, targetPos);

            // Re-center cursor for next trial if needed
            cursor = { x: startPos.x, y: startPos.y };
            lastInput = { x: startPos.x, y: startPos.y };
            drawScreen();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Mouse movement handler
        canvas.onmousemove = function(e) {
            moveHandler(e.clientX, e.clientY);
        };

        // Touch support for tablets/phones!
        canvas.addEventListener('touchmove', function(e) {
            if (trial >= TRIALS) return;
            if (e.touches.length !== 1) return; // single finger only
            let touch = e.touches[0];
            // Get coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            let touchX = touch.clientX - rect.left;
            let touchY = touch.clientY - rect.top;
            moveHandler(touchX, touchY);
            e.preventDefault();
        }, {passive: false}); // so we can prevent scroll

        function moveHandler(inputX, inputY) {
            if (trial >= TRIALS) return;

            if (trialStartFlag) {
                lastInput = {x: inputX, y: inputY};
                trialStartFlag = false;
                drawScreen();
                return;
            }

            let dx = inputX - lastInput.x;
            let dy = inputY - lastInput.y;

            let r = rotate(dx, dy, ROTATION_ANGLE);

            cursor.x += r.x;
            cursor.y += r.y;
            cursor.x = Math.max(0, Math.min(w, cursor.x));
            cursor.y = Math.max(0, Math.min(h, cursor.y));

            lastInput = {x: inputX, y: inputY};
            drawScreen();

            let curDist = dist(cursor, startPos);
            if (curDist >= requiredDistance) {
                let reachVec = {x: cursor.x - startPos.x, y: cursor.y - startPos.y};
                let reachDeg = getAngleDeg(reachVec);
                reachAngles.push(reachDeg);

                let targetVec = {x: targetPos.x - startPos.x, y: targetPos.y - startPos.y};
                let targetDeg = getAngleDeg(targetVec);
                let errDeg = angleDiffDeg(reachDeg, targetDeg);
                errorAngles.push(errDeg);

                trial++;
                if (trial < TRIALS) {
                    cursor = { x: startPos.x, y: startPos.y };
                    trialStartFlag = true;
                    drawScreen();
                } else {
                    finishExperiment();
                }
            }
        }

        function finishExperiment() {
            drawScreen();
            ctx.font = "32px Arial";
            ctx.fillStyle = "black";
            ctx.fillText("Experiment complete!", w/2-170, h/2-70);
            plotResults();
        }

        function plotResults() {
            const plotDiv = document.getElementById('plot');
            plotDiv.style.display = "block";
            plotDiv.innerHTML = "<b>Results:</b><br>";

            function svgPlot(data, labelY, labelTitle, color) {
                let width = Math.min(500, w*0.7), height = 230, pad = 40;
                let maxY = Math.max(...data), minY = Math.min(...data);
                if (maxY-minY < 40) { maxY += 20; minY -= 20; }
                let pts = data.map((y, i) => {
                    let x = pad + i * (width - 2*pad)/(TRIALS-1);
                    let yPos = height-pad - ((y - minY)*(height-pad-pad))/(maxY-minY+1e-6);
                    return {x, y:yPos};
                });

                let pointsStr = pts.map((p,i) => (i === 0 ? `M${p.x},${p.y}` : `L${p.x},${p.y}`)).join(" ");
                let circlesStr = pts.map((p,i) => `<circle cx="${p.x}" cy="${p.y}" r="4" fill="${color}" />`).join('');

                return `<svg width="${width}" height="${height}" style="background:#fcfcff;border:1px solid #ccc;margin-bottom:20px">
                    <text x="${pad}" y="22" font-size="16">${labelTitle}</text>
                    <text x="${width/2-20}" y="${height-pad+32}" font-size="13">Trial</text>
                    <text x="14" y="${pad+10}" font-size="13" transform="rotate(-90,14,${pad+10})">${labelY}</text>
                    <line x1="${pad}" y1="${height-pad}" x2="${width-pad}" y2="${height-pad}" stroke="#555"/>
                    <line x1="${pad}" y1="${pad}" x2="${pad}" y2="${height-pad}" stroke="#555"/>
                    ${[minY, maxY].map((v,i) => {
                            let yPos = height-pad - ((v - minY)*(height-pad-pad))/(maxY-minY+1e-6);
                            return `<text x="6" y="${yPos+4}" font-size="11">${v.toFixed(1)}</text>
                                     <line x1="${pad-5}" y1="${yPos}" x2="${pad}" y2="${yPos}" stroke="#888"/>`;
                        }).join('')}
                    <path d="${pointsStr}" stroke="${color}" stroke-width="2" fill="none"/>
                    ${circlesStr}
                </svg>`;
            }

            plotDiv.innerHTML += svgPlot(
                reachAngles, "Reach angle (deg)",
                "Reach angles from home per trial", "#3297D4"
            );
            plotDiv.innerHTML += svgPlot(
                errorAngles, "Error angle (deg)",
                "Error angles (relative to target) per trial", "#D43432"
            );
        }
    </script>
</body>
</html>
