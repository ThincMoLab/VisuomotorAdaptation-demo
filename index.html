<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Visuomotor Adaptation Demo</title>
  <style>
    canvas { 
        background: #eef; 
        display: block; 
        margin: 1em auto;
        cursor: none;    /* Hide system pointer */
    }
    #plots { display: none; }
    #taskArea { text-align: center; }
    body { font-family: Arial, sans-serif; }
  </style>
</head>
<body>
<h2 style="text-align:center;">Visuomotor Adaptation Demo</h2>
<div id="taskArea">
  <canvas id="canvas" width="600" height="600"></canvas>
  <div id="info"></div>
</div>
<div id="plots">
  <h3 style="text-align:center;">Results</h3>
  <canvas id="plot1" width="600" height="300"></canvas>
  <canvas id="plot2" width="600" height="300"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// === Parameters ===
const nTrials = 30;
const home = {x:300, y:500};
const target = {x:300, y:100};
const targetRadius = 12;
const homeRadius = 15;
const cursorRadius = 7;
const reachDistance = Math.abs(home.y - target.y);
const rotationDeg = 30;
const rotationRad = rotationDeg * Math.PI/180;
const gain = 1.0;      // 1:1 amplitude

let trial = 0;
let isTrialActive = false;
let cursorPos = {}; // physical visual "cursor" position from hand movement
let handStart = null; // records hand start
let reachDirections = [];
let cursorAngles = [];
let angleErrors = [];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');

// ===== Drawing =====
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // home
    ctx.beginPath();
    ctx.arc(home.x, home.y, homeRadius, 0, 2*Math.PI);
    ctx.fillStyle = "#88F";
    ctx.fill();

    // target
    ctx.beginPath();
    ctx.arc(target.x, target.y, targetRadius, 0, 2*Math.PI);
    ctx.fillStyle = "#F88";
    ctx.fill();

    // cursor (only at current position)
    if (cursorPos.x !== undefined && cursorPos.y !== undefined) {
        ctx.beginPath();
        ctx.arc(cursorPos.x, cursorPos.y, cursorRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "#444";
        ctx.fill();
    }
}

function setInfo(msg) {
    info.innerHTML = msg;
}

// On page load, place cursor at home (simulate first pointer event at home)
cursorPos = {...home};
draw();
setInfo('Move your cursor (pointer) to the blue circle, then press down and move toward the target. You must move the cursor back to home by yourself after each trial.');

// ==== Global pointer tracking (even off canvas as needed) ====
function globalPointerMove(e) {
    const rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    if (isTrialActive) {
        updateCursorFromHand(mx, my);
    } else {
        // Just render the cursor (rotated) so user can line up at home
        // displacement from "handStart" (not used between trials, so reference to pointer position)
        let dx = mx - home.x;
        let dy = my - home.y;
        let r = Math.sqrt(dx*dx + dy*dy) * gain;
        let theta = Math.atan2(dy, dx);
        let thetaVis = theta + rotationRad;
        cursorPos.x = home.x + r * Math.cos(thetaVis);
        cursorPos.y = home.y + r * Math.sin(thetaVis);
        draw();
    }
}

window.addEventListener('pointermove', globalPointerMove);

// ==== Start trial logic ====
// Only allow trial start if pointer and cursor BOTH at home!
canvas.addEventListener('pointerdown', function(e) {
    if (trial >= nTrials) return;
    if (isTrialActive) return;
    const rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;

    // For 1:1 gain, cursorPos is always updated with pointermove so up to date.
    let pointerDist = Math.hypot(mx-home.x, my-home.y);
    let cursorDist = Math.hypot(cursorPos.x-home.x, cursorPos.y-home.y);
    if (pointerDist < homeRadius && cursorDist < homeRadius) {
        // Start trial!
        handStart = {x: mx, y: my};
        isTrialActive = true;
        setInfo(`Trial ${trial+1}/${nTrials}: Move the cursor towards the target...`);
    } else {
        setInfo(`To start, move both your pointer AND the cursor to the blue circle, then press down.`);
    }
});

function updateCursorFromHand(mx, my) {
    // Calculate hand movement vector from home
    let dx = mx - handStart.x;
    let dy = my - handStart.y;
    let r = Math.sqrt(dx*dx + dy*dy) * gain;
    let theta = Math.atan2(dy, dx);
    // Apply rotation
    let thetaVis = theta + rotationRad;
    cursorPos.x = home.x + r * Math.cos(thetaVis);
    cursorPos.y = home.y + r * Math.sin(thetaVis);
    draw();

    let cursorDist = Math.hypot(cursorPos.x-home.x, cursorPos.y-home.y);
    if (cursorDist >= reachDistance) {
        finishTrial(theta, thetaVis);
    }
}

function finishTrial(handTheta, cursorTheta) {
    isTrialActive = false;
    let handAngleDeg = handTheta * 180 / Math.PI;
    let cursorAngleDeg = cursorTheta * 180 / Math.PI;
    let targetDx = target.x - home.x;
    let targetDy = target.y - home.y;
    let targetAngleRad = Math.atan2(targetDy, targetDx);
    let targetAngleDeg = targetAngleRad * 180 / Math.PI;
    let errorAngle = cursorAngleDeg - targetAngleDeg;

    reachDirections.push(handAngleDeg);
    cursorAngles.push(cursorAngleDeg);
    angleErrors.push(errorAngle);

    trial++;
    setInfo(`Trial ${trial}/${nTrials} completed.<br>
      <b>Move both your pointer and the cursor back to the blue circle to start the next trial.</b>`);

    draw(); // Show cursor/circle at current location
    // Next trial will only begin if pointer & cursor are both at "home"
    if (trial >= nTrials) {
        setInfo("Trials finished!");
        setTimeout(endTask, 500);
    }
}

canvas.addEventListener('touchstart', e => { e.preventDefault(); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); });

function endTask() {
    document.getElementById('taskArea').style.display = "none";
    document.getElementById('plots').style.display = "block";
    const targetAngleDeg = Math.atan2(target.y-home.y, target.x-home.x) * 180/Math.PI;
    const handTargetErrors = reachDirections.map(a => a - targetAngleDeg);

    // Plot: Hand-Target angle error
    new Chart(document.getElementById('plot1'),{
        type:'line',
        data:{
            labels: [...Array(nTrials).keys()].map(x=>x+1),
            datasets:[
                {
                    label: "Hand-Target Angle Error (deg)",
                    data: handTargetErrors,
                    borderColor: "#88F",
                    pointStyle:'cross',
                    fill:false
                }
            ]
        },
        options:{responsive:false,
            plugins:{title:{display:true,text:"Hand-Target angle error per trial"}},
            scales:{
                y:{beginAtZero:false, title:{text:"Angular error (deg)",display:true}},
                x:{title:{text:"Trial#",display:true}}
            }
        }
    });

    // Second plot: cursor-target error (as before)
    new Chart(document.getElementById('plot2'),{
        type:'line',
        data:{
            labels: [...Array(nTrials).keys()].map(x=>x+1),
            datasets:[{
                label:"Cursor-Target Angle Error (deg)",
                data: angleErrors,
                borderColor: "#F88",
                fill:false
            }]
        },
        options:{responsive:false,
            plugins:{title:{display:true,text:"Cursor angle error vs trial"}},
            scales:{y:{beginAtZero:false, title:{text:"Angular error (deg)",display:true}}, x:{title:{text:"Trial#",display:true}}}
        }
    });
}
</script>
</body>
</html>
